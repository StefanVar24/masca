diff --git a/index.js b/index.js
index a63218b73bb5cb1d566962fac9360689341fcae0..b4a4b79a929bbc800049f030a3c9fc6b1970a241 100644
--- a/index.js
+++ b/index.js
@@ -5,12 +5,14 @@
 
 "use strict";
 
-const EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');
+const EC_GROUP_ORDER = Buffer.from(
+  "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
+  "hex"
+);
 const ZERO32 = Buffer.alloc(32, 0);
 
-var promise = typeof Promise === "undefined" ?
-              require("es6-promise").Promise :
-              Promise;
+var promise =
+  typeof Promise === "undefined" ? require("es6-promise").Promise : Promise;
 var crypto = require("crypto");
 // try to use secp256k1, fallback to browser implementation
 try {
@@ -20,22 +22,23 @@ try {
   if (process.env.ECCRYPTO_NO_FALLBACK) {
     throw e;
   } else {
-    console.info('secp256k1 unavailable, reverting to browser version');
-    return (module.exports = require("./browser"));
+    console.info("secp256k1 unavailable, reverting to browser version");
+    module.exports = require("./browser");
   }
 }
 
-function isScalar (x) {
+function isScalar(x) {
   return Buffer.isBuffer(x) && x.length === 32;
 }
 
 function isValidPrivateKey(privateKey) {
-  if (!isScalar(privateKey))
-  {
+  if (!isScalar(privateKey)) {
     return false;
   }
-  return privateKey.compare(ZERO32) > 0 && // > 0
-  privateKey.compare(EC_GROUP_ORDER) < 0; // < G
+  return (
+    privateKey.compare(ZERO32) > 0 && // > 0
+    privateKey.compare(EC_GROUP_ORDER) < 0
+  ); // < G
 }
 
 function assert(condition, message) {
@@ -73,12 +76,12 @@ function equalConstTime(b1, b2) {
   }
   var res = 0;
   for (var i = 0; i < b1.length; i++) {
-    res |= b1[i] ^ b2[i];  // jshint ignore:line
+    res |= b1[i] ^ b2[i]; // jshint ignore:line
   }
   return res === 0;
 }
 
-function pad32(msg){
+function pad32(msg) {
   var buf;
   if (msg.length < 32) {
     buf = Buffer.alloc(32);
@@ -95,7 +98,7 @@ function pad32(msg){
  * @return {Buffer} A 32-byte private key.
  * @function
  */
-exports.generatePrivate = function() {
+exports.generatePrivate = function () {
   var privateKey = crypto.randomBytes(32);
   while (!isValidPrivateKey(privateKey)) {
     privateKey = crypto.randomBytes(32);
@@ -109,23 +112,24 @@ exports.generatePrivate = function() {
  * @return {Buffer} A 65-byte public key.
  * @function
  */
-var getPublic = exports.getPublic = function(privateKey) {
+var getPublic = (exports.getPublic = function (privateKey) {
   assert(privateKey.length === 32, "Bad private key");
   assert(isValidPrivateKey(privateKey), "Bad private key");
   // See https://github.com/wanderer/secp256k1-node/issues/46
   var compressed = secp256k1.publicKeyCreate(privateKey);
   return secp256k1.publicKeyConvert(compressed, false);
-};
+});
 
 /**
  * Get compressed version of public key.
  */
-var getPublicCompressed = exports.getPublicCompressed = function(privateKey) { // jshint ignore:line
+var getPublicCompressed = (exports.getPublicCompressed = function (privateKey) {
+  // jshint ignore:line
   assert(privateKey.length === 32, "Bad private key");
   assert(isValidPrivateKey(privateKey), "Bad private key");
   // See https://github.com/wanderer/secp256k1-node/issues/46
   return secp256k1.publicKeyCreate(privateKey);
-};
+});
 
 /**
  * Create an ECDSA signature.
@@ -134,8 +138,8 @@ var getPublicCompressed = exports.getPublicCompressed = function(privateKey) { /
  * @return {Promise.<Buffer>} A promise that resolves with the
  * signature and rejects on bad key or message.
  */
-exports.sign = function(privateKey, msg) {
-  return new promise(function(resolve) {
+exports.sign = function (privateKey, msg) {
+  return new promise(function (resolve) {
     assert(privateKey.length === 32, "Bad private key");
     assert(isValidPrivateKey(privateKey), "Bad private key");
     assert(msg.length > 0, "Message should not be empty");
@@ -154,16 +158,16 @@ exports.sign = function(privateKey, msg) {
  * @return {Promise.<null>} A promise that resolves on correct signature
  * and rejects on bad key or signature.
  */
-exports.verify = function(publicKey, msg, sig) {
-  return new promise(function(resolve, reject) {
+exports.verify = function (publicKey, msg, sig) {
+  return new promise(function (resolve, reject) {
     assert(msg.length > 0, "Message should not be empty");
     assert(msg.length <= 32, "Message is too long");
     msg = pad32(msg);
     sig = secp256k1.signatureImport(sig);
     if (secp256k1.verify(msg, sig, publicKey)) {
-     resolve(null);
+      resolve(null);
     } else {
-     reject(new Error("Bad signature"));
+      reject(new Error("Bad signature"));
     }
   });
 };
@@ -175,13 +179,13 @@ exports.verify = function(publicKey, msg, sig) {
  * @return {Promise.<Buffer>} A promise that resolves with the derived
  * shared secret (Px, 32 bytes) and rejects on bad key.
  */
-var derive = exports.derive = function(privateKeyA, publicKeyB) {
-  return new promise(function(resolve) {
+var derive = (exports.derive = function (privateKeyA, publicKeyB) {
+  return new promise(function (resolve) {
     assert(privateKeyA.length === 32, "Bad private key");
     assert(isValidPrivateKey(privateKeyA), "Bad private key");
     resolve(ecdh.derive(privateKeyA, publicKeyB));
   });
-};
+});
 
 /**
  * Input/output structure for ECIES operations.
@@ -202,20 +206,19 @@ var derive = exports.derive = function(privateKeyA, publicKeyB) {
  * @return {Promise.<Ecies>} - A promise that resolves with the ECIES
  * structure on successful encryption and rejects on failure.
  */
-exports.encrypt = function(publicKeyTo, msg, opts) {
+exports.encrypt = function (publicKeyTo, msg, opts) {
   opts = opts || {};
   // Tmp variable to save context from flat promises;
   var ephemPublicKey;
-  return new promise(function(resolve) {
+  return new promise(function (resolve) {
     var ephemPrivateKey = opts.ephemPrivateKey || crypto.randomBytes(32);
     // There is a very unlikely possibility that it is not a valid key
-    while(!isValidPrivateKey(ephemPrivateKey))
-    {
+    while (!isValidPrivateKey(ephemPrivateKey)) {
       ephemPrivateKey = opts.ephemPrivateKey || crypto.randomBytes(32);
     }
     ephemPublicKey = getPublic(ephemPrivateKey);
     resolve(derive(ephemPrivateKey, publicKeyTo));
-  }).then(function(Px) {
+  }).then(function (Px) {
     var hash = sha512(Px);
     var iv = opts.iv || crypto.randomBytes(16);
     var encryptionKey = hash.slice(0, 32);
@@ -240,8 +243,8 @@ exports.encrypt = function(publicKeyTo, msg, opts) {
  * @return {Promise.<Buffer>} - A promise that resolves with the
  * plaintext on successful decryption and rejects on failure.
  */
-exports.decrypt = function(privateKey, opts) {
-  return derive(privateKey, opts.ephemPublicKey).then(function(Px) {
+exports.decrypt = function (privateKey, opts) {
+  return derive(privateKey, opts.ephemPublicKey).then(function (Px) {
     assert(privateKey.length === 32, "Bad private key");
     assert(isValidPrivateKey(privateKey), "Bad private key");
     var hash = sha512(Px);
@@ -250,9 +253,10 @@ exports.decrypt = function(privateKey, opts) {
     var dataToMac = Buffer.concat([
       opts.iv,
       opts.ephemPublicKey,
-      opts.ciphertext
+      opts.ciphertext,
     ]);
     var realMac = hmacSha256(macKey, dataToMac);
-    assert(equalConstTime(opts.mac, realMac), "Bad MAC"); return aes256CbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);
+    assert(equalConstTime(opts.mac, realMac), "Bad MAC");
+    return aes256CbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);
   });
 };